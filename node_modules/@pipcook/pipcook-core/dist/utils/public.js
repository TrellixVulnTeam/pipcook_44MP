"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateId = exports.shuffle = exports.getOsInfo = exports.convertPascal2CocoFileOutput = exports.transformCsv = exports.getMetadata = exports.getModelDir = exports.unZipData = exports.compressTarFile = exports.downloadAndExtractTo = exports.download = exports.parseAnnotation = exports.createAnnotationFromJson = exports.createAnnotationFile = void 0;
const url = __importStar(require("url"));
const util_1 = require("util");
const path = __importStar(require("path"));
const fs = __importStar(require("fs-extra"));
const nanoid_1 = require("nanoid");
const cli_progress_1 = __importDefault(require("cli-progress"));
const other_1 = require("../constants/other");
const xml2js = require('xml2js');
const request = require('request');
const si = require('systeminformation');
const targz = require('targz');
const extract = require('extract-zip');
const nanoid = nanoid_1.customAlphabet('1234567890abcdefghijklmnopqrstuvwxyz', 8);
const compressAsync = util_1.promisify(targz.compress);
const extractAsync = util_1.promisify(extract);
/**
 * This function is used to create annotation file for image claasifiaction.  PASCOL VOC format.
 * For more info, you can check the sources codes of plugin: @pipcook/pipcook-plugins-image-class-data-collect
 * @param annotationDir : annotation directory
 * @param filename : image file name
 * @param url : image path
 * @param category : image classification category name
 */
function createAnnotationFile(annotationDir, filename, url, category) {
    return __awaiter(this, void 0, void 0, function* () {
        const json = {
            annotation: {
                filename: [filename],
                folder: [url],
                object: [
                    {
                        name: [category]
                    }
                ]
            }
        };
        const fileNameSplit = filename.split('.');
        filename = fileNameSplit.slice(0, fileNameSplit.length - 1).join('.');
        const xml = (new xml2js.Builder()).buildObject(json);
        yield fs.outputFile(path.join(annotationDir, `${filename}.xml`), xml);
    });
}
exports.createAnnotationFile = createAnnotationFile;
/**
 * create annotation file for object detection. PASCOL VOC format.
 * For more info, you can check the sources codes of plugin: @pipcook/pipcook-plugins-image-detection-data-collect
 * @param annotationDir : annotation directory
 * @param json : json file that will be filled into xml
 */
function createAnnotationFromJson(annotationDir, json) {
    return __awaiter(this, void 0, void 0, function* () {
        let filename = json.annotation.filename[0];
        const fileNameSplit = filename.split('.');
        filename = fileNameSplit.slice(0, fileNameSplit.length - 1).join('.');
        const xml = (new xml2js.Builder()).buildObject(json);
        yield fs.outputFile(path.join(annotationDir, `${filename}.xml`), xml);
    });
}
exports.createAnnotationFromJson = createAnnotationFromJson;
/**
 * parse the xml file and read into json data
 * filename: file path of xml file
 */
function parseAnnotation(filename) {
    return __awaiter(this, void 0, void 0, function* () {
        const fileContent = yield fs.readFile(filename);
        const parser = new xml2js.Parser();
        const jsonData = yield parser.parseStringPromise(fileContent);
        return jsonData;
    });
}
exports.parseAnnotation = parseAnnotation;
/**
 * download the file and stored in specified directory
 * @param url: url of the file
 * @param: full path of file that will be stored
 */
function download(url, fileName) {
    return __awaiter(this, void 0, void 0, function* () {
        yield fs.ensureFile(fileName);
        return new Promise((resolve, reject) => {
            const bar1 = new cli_progress_1.default.SingleBar({}, cli_progress_1.default.Presets.shades_classic);
            const file = fs.createWriteStream(fileName);
            let receivedBytes = 0;
            request.get(url)
                .on('response', (response) => {
                const totalBytes = response.headers['content-length'];
                bar1.start(totalBytes, 0);
            })
                .on('data', (chunk) => {
                receivedBytes += chunk.length;
                bar1.update(receivedBytes);
            })
                .pipe(file)
                .on('error', (err) => {
                fs.unlink(fileName);
                bar1.stop();
                reject(err);
            });
            file.on('finish', () => {
                bar1.stop();
                resolve();
            });
            file.on('error', (err) => {
                fs.unlink(fileName);
                bar1.stop();
                reject(err);
            });
        });
    });
}
exports.download = download;
/**
 * Download the dataset from specific URL and extract to a generated path as the returned value.
 * @param resUrl the resource url, support http://, https://, file:///.
 */
function downloadAndExtractTo(resUrl) {
    return __awaiter(this, void 0, void 0, function* () {
        const filename = resUrl.split(path.sep)[resUrl.split(path.sep).length - 1];
        const extname = path.extname(filename);
        const { protocol, pathname } = url.parse(resUrl);
        const destPath = path.join(other_1.PIPCOOK_TMPDIR, generateId());
        const pkgName = path.join(destPath, filename);
        if (protocol === 'file:' && extname !== '.zip') {
            yield fs.copy(pathname, destPath);
            return destPath;
        }
        if (protocol === 'http:' || protocol === 'https:') {
            yield download(resUrl, pkgName);
        }
        else if (protocol === 'file:') {
            yield fs.copyFile(pathname, pkgName);
        }
        if (extname === '.zip') {
            yield unZipData(pkgName, destPath);
            yield fs.remove(pkgName);
        }
        else {
            return pkgName;
        }
        return destPath;
    });
}
exports.downloadAndExtractTo = downloadAndExtractTo;
function compressTarFile(sourcePath, targetPath) {
    return compressAsync({ src: sourcePath, dest: targetPath });
}
exports.compressTarFile = compressTarFile;
/**
 * unzip compressed data
 * @param filePath : path of zip
 * @param targetPath : target full path
 */
function unZipData(filePath, targetPath) {
    return extractAsync(filePath, { dir: targetPath });
}
exports.unZipData = unZipData;
/**
 * get pipcook model path
 */
function getModelDir(jobId) {
    return path.join(other_1.PIPCOOK_LOGS, jobId, 'model');
}
exports.getModelDir = getModelDir;
/**
 * get pipcook log's sample data's metadata according to modelId
 */
function getMetadata(jobId) {
    const json = require(path.join(other_1.PIPCOOK_LOGS, jobId, `log.json`));
    return json && json.metadata;
}
exports.getMetadata = getMetadata;
/**
 * transform a string to its csv suitable format
 * @param text the text to be converted
 */
function transformCsv(text) {
    if (text.includes(',')) {
        if (text.includes('"')) {
            let newText = '';
            for (let i = 0; i < text.length; i++) {
                if (text[i] === '"') {
                    newText += `""`;
                }
                else {
                    newText += text[i];
                }
            }
            text = newText;
        }
        text = `"${text}"`;
    }
    return text;
}
exports.transformCsv = transformCsv;
/**
 * converter between PASCOL VOC format and COCO data format
 * @param files : paths of xml files
 * @param targetPath target output path
 */
function convertPascal2CocoFileOutput(files, targetPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const cocoJson = {
            info: {
                "description": "dataset generated by pipcook",
                "url": "http:\/\/mscoco.org",
                "version": "1.0", "year": 2014,
                "contributor": "Microsoft COCO group",
                "date_created": "2015-01-27 09:11:52.357475"
            },
            images: [],
            licenses: [
                {
                    "url": "http:\/\/creativecommons.org\/licenses\/by-nc-sa\/2.0\/",
                    "id": 1,
                    "name": "Attribution-NonCommercial-ShareAlike License"
                }
            ],
            annotations: [],
            categories: []
        };
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            const xmlJson = yield parseAnnotation(file);
            const imageItem = {
                license: 1,
                file_name: xmlJson.annotation.filename[0],
                coco_url: xmlJson.annotation.folder[0],
                id: i + 1
            };
            if (xmlJson.annotation.size && xmlJson.annotation.size[0]) {
                imageItem.width = parseInt(xmlJson.annotation.size[0].width[0]);
                imageItem.height = parseInt(xmlJson.annotation.size[0].height[0]);
            }
            cocoJson.images.push(imageItem);
            if (!(xmlJson.annotation && xmlJson.annotation.object && xmlJson.annotation.object.length > 0)) {
                continue;
            }
            xmlJson.annotation.object.forEach((item) => {
                const name = item.name[0];
                const category = cocoJson.categories.find((e) => e.name === name);
                let id;
                if (category) {
                    id = category.id;
                }
                else {
                    id = cocoJson.categories.length + 1;
                    cocoJson.categories.push({
                        id,
                        name,
                        supercategory: name
                    });
                }
                const cocoItem = {
                    id: cocoJson.annotations.length + 1,
                    image_id: i + 1,
                    category_id: id,
                    iscrowd: Number((item.iscrowd && item.iscrowd[0])) || 0
                };
                if (item.segmentation && item.segmentation[0]) {
                    if (item.segmentation[0].counts) {
                        cocoItem.segmentation = {
                            counts: item.segmentation[0].counts[0],
                            size: [
                                Number(item.segmentation[0].size[0]),
                                Number(item.segmentation[0].size[1])
                            ]
                        };
                    }
                    else if (item.segmentation[0].polygon) {
                        cocoItem.segmentation = item.segmentation[0].polygon[0];
                    }
                }
                if (item.bndbox && item.bndbox[0]) {
                    const width = parseInt(item.bndbox[0].xmax[0]) - parseInt(item.bndbox[0].xmin[0]);
                    const height = parseInt(item.bndbox[0].ymax[0]) - parseInt(item.bndbox[0].ymin[0]);
                    cocoItem.bbox = [parseInt(item.bndbox[0].xmin[0]), parseInt(item.bndbox[0].ymin[0]), width, height];
                    cocoItem.area = Number(width * height);
                }
                cocoJson.annotations.push(cocoItem);
            });
        }
        yield fs.outputJSON(targetPath, cocoJson);
    });
}
exports.convertPascal2CocoFileOutput = convertPascal2CocoFileOutput;
/**
 * return that current system is:
 * mac / linux / windows / other
 */
function getOsInfo() {
    return new Promise((resolve, reject) => {
        si.osInfo((info, err) => {
            if (err) {
                reject(err);
                return;
            }
            if (info.platform === 'linux') {
                resolve('linux');
            }
            else if (info.platform === 'win32') {
                resolve('windows');
            }
            else if (info.platform === 'darwin') {
                resolve('mac');
            }
            else {
                resolve('other');
            }
        });
    });
}
exports.getOsInfo = getOsInfo;
/**
 * Shuffles array in place. ES6 version. This method is based on Fisher-Yates shuffle algorithm
 * @param array An array containing the items.
 */
function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}
exports.shuffle = shuffle;
/**
 * generate id
 */
function generateId() {
    return nanoid();
}
exports.generateId = generateId;
//# sourceMappingURL=public.js.map