#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const path_1 = __importDefault(require("path"));
const commander_1 = __importDefault(require("commander"));
const fs_extra_1 = require("fs-extra");
const pipcook_core_1 = require("@pipcook/pipcook-core");
const common_1 = require("../utils/common");
const PIPCOOK_HOME = pipcook_core_1.constants.PIPCOOK_HOME_PATH;
const DAEMON_HOME = pipcook_core_1.constants.PIPCOOK_DAEMON_SRC;
const ACCESS_LOG = path_1.default.join(PIPCOOK_HOME, 'daemon.access.log');
const DAEMON_PIDFILE = path_1.default.join(PIPCOOK_HOME, 'daemon.pid');
const BOOTSTRAP_HOME = path_1.default.join(DAEMON_HOME, 'bootstrap.js');
function start() {
    return __awaiter(this, void 0, void 0, function* () {
        // check if the process is running...
        if (yield fs_extra_1.pathExists(DAEMON_PIDFILE)) {
            return common_1.logger.fail(`starting daemon but ${DAEMON_PIDFILE} exists.`);
        }
        common_1.logger.start('starting Pipcook...');
        const daemon = child_process_1.fork(BOOTSTRAP_HOME, [], {
            cwd: DAEMON_HOME,
            stdio: 'ignore',
            detached: true
        });
        daemon.on('message', (message) => {
            if (message.event === 'ready') {
                daemon.disconnect();
                daemon.unref();
                common_1.logger.success(`Pipcook is on http://localhost:${message.data.listen}`);
            }
        });
        daemon.on('exit', (code) => __awaiter(this, void 0, void 0, function* () {
            common_1.logger.fail(`Pipcook daemon starts failed with code(${code}).`, false);
            // TODO(yorkie): check if this is local mode.
            console.error(yield fs_extra_1.readFile(ACCESS_LOG, 'utf8'));
        }));
    });
}
function stop() {
    return __awaiter(this, void 0, void 0, function* () {
        common_1.logger.start('stoping Pipcook...');
        if (yield fs_extra_1.pathExists(DAEMON_PIDFILE)) {
            const oldPid = parseInt(yield fs_extra_1.readFile(DAEMON_PIDFILE, 'utf8'), 10);
            try {
                process.kill(oldPid, 'SIGINT');
                common_1.logger.success('Pipcook stopped.');
            }
            catch (err) {
                yield fs_extra_1.remove(DAEMON_PIDFILE);
                common_1.logger.success(`kill ${oldPid} failed, skiped and removed pidfile.`);
            }
        }
        else {
            common_1.logger.success('skiped, daemon is not running.');
        }
    });
}
function tail(file) {
    child_process_1.spawn('tail', ['-f', file], { stdio: 'inherit' });
}
function monitor() {
    return __awaiter(this, void 0, void 0, function* () {
        tail(ACCESS_LOG);
    });
}
function debugDaemon() {
    return __awaiter(this, void 0, void 0, function* () {
        yield stop();
        process.env.DEBUG = 'costa*';
        require(BOOTSTRAP_HOME);
    });
}
commander_1.default
    .command('start')
    .description('start the pipcook daemon.')
    .action(start);
commander_1.default
    .command('restart')
    .description('restart pipcook daemon')
    .action(() => __awaiter(void 0, void 0, void 0, function* () {
    yield stop();
    yield start();
}));
commander_1.default
    .command('stop')
    .description('stop the pipcook daemon.')
    .action(stop);
commander_1.default
    .command('monit')
    .description('monit the daemon logs.')
    .action(monitor);
commander_1.default
    .command('logfile')
    .description('print the path of logfile')
    .action(() => {
    console.info(ACCESS_LOG);
});
commander_1.default
    .command('debug')
    .description('start the pipcook daemon in foreground for debugging.')
    .action(debugDaemon);
commander_1.default.parse(process.argv);
//# sourceMappingURL=pipcook-daemon.js.map