"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppProject = void 0;
const path_1 = require("path");
const zlib_1 = require("zlib");
const tar_stream_1 = __importDefault(require("tar-stream"));
const fs_extra_1 = require("fs-extra");
const request_1 = require("../utils/request");
const router_1 = require("../utils/router");
const config_1 = require("../config");
const pipcook_core_1 = require("@pipcook/pipcook-core");
const common_1 = require("../utils/common");
const { cwd } = process;
/**
 * The PipApp project management
 */
class AppProject {
    /**
     * To create a AppProject instance from a main script pathname.
     * @param mainScriptPath The main script pathname
     */
    constructor(mainScriptPath) {
        this.downloadSingleOutput = (job) => __awaiter(this, void 0, void 0, function* () {
            const modelPath = path_1.join(this.modelRootPath, job.id);
            const extract = tar_stream_1.default.extract();
            extract.on('entry', (header, stream, next) => __awaiter(this, void 0, void 0, function* () {
                const dist = path_1.join(modelPath, header.name);
                if (header.type === 'directory') {
                    yield fs_extra_1.mkdirp(dist);
                }
                else if (header.type === 'file') {
                    stream.pipe(fs_extra_1.createWriteStream(dist));
                }
                stream.on('end', next);
                stream.resume();
            }));
            (yield request_1.getFile(`${router_1.route.job}/${job.id}/output.tar.gz`))
                .pipe(zlib_1.createGunzip())
                .pipe(extract);
            return new Promise((resolve) => {
                extract.on('finish', () => resolve(modelPath));
            });
        });
        this.mainScriptPath = path_1.join(cwd(), mainScriptPath);
        this.rootPath = path_1.dirname(this.mainScriptPath);
        this.pipcookPath = path_1.join(this.rootPath, '.pipcook');
        this.manifestPath = path_1.join(this.pipcookPath, 'manifest.json');
        this.modelRootPath = path_1.join(this.pipcookPath, 'models');
    }
    /**
     * Initialize the app project or load from given location.
     */
    initializeOrLoad() {
        return __awaiter(this, void 0, void 0, function* () {
            this.mainScriptSource = yield fs_extra_1.readFile(this.mainScriptPath, 'utf8');
            yield fs_extra_1.ensureDir(this.pipcookPath);
            if (yield fs_extra_1.pathExists(this.manifestPath)) {
                this.manifest = yield fs_extra_1.readJSON(this.manifestPath);
            }
            else {
                this.manifest = {
                    script: this.mainScriptPath,
                    pipelines: null
                };
            }
        });
    }
    /**
     * Compile the current project, and save manifest locally.
     */
    compileAndSave() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.manifest.pipelines === null) {
                const { pipelines, executableSource } = yield request_1.post(`${router_1.route.app}/compile`, { src: this.mainScriptSource });
                this.manifest.pipelines = pipelines.map((pipeline) => {
                    return {
                        id: pipeline.id,
                        signature: pipeline.signature,
                        namespace: pipeline.namespace
                    };
                });
                const targetFilename = path_1.basename(this.mainScriptPath).replace(/\.ts$/, '');
                yield fs_extra_1.writeFile(`${this.rootPath}/${targetFilename}.ml.js`, executableSource, 'utf8');
                yield this.saveManifest();
            }
        });
    }
    /**
     * Train the project via the generated pipelines.
     */
    train(hooks) {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            const jobIds = [];
            try {
                for (var _b = __asyncValues(this.manifest.pipelines), _c; _c = yield _b.next(), !_c.done;) {
                    const pipeline = _c.value;
                    const { id } = pipeline;
                    yield (hooks === null || hooks === void 0 ? void 0 : hooks.before(id));
                    const job = yield request_1.get(`${router_1.route.job}/run`, {
                        cwd: cwd(),
                        pipelineId: id,
                        pyIndex: config_1.tunaMirrorURI
                    });
                    jobIds.push(job.id);
                    pipeline.jobId = job.id;
                    yield (hooks === null || hooks === void 0 ? void 0 : hooks.after(id, job.id));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            // save the jobIds
            // TODO(yorkie): check if currently running?
            this.manifest.jobIds = jobIds;
            yield this.saveManifest();
        });
    }
    /**
     * Get the instances for every job.
     */
    getJobs() {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.all(this.manifest.jobIds.map((id) => __awaiter(this, void 0, void 0, function* () {
                return yield request_1.get(`${router_1.route.job}/${id}`);
            })));
        });
    }
    /**
     * Generate the PipApp executable.
     */
    buildExecutable({ tuna }) {
        return __awaiter(this, void 0, void 0, function* () {
            // fetch jobs and verify if it's able to generate exec.
            let jobs = yield this.getJobs();
            jobs = jobs.filter((job) => {
                if (job.status === pipcook_core_1.PipelineStatus.RUNNING || job.status === pipcook_core_1.PipelineStatus.INIT) {
                    // just throw when there is a job is running or initializing.
                    throw new TypeError(`job(${job.id}) is running or initializing, please wait.`);
                }
                else if (job.status === pipcook_core_1.PipelineStatus.FAIL) {
                    // just skip if a job is failed.
                    console.warn(`skip job(${job.id}) because failure of "${job.error}"`);
                    return false;
                }
                else if (job.status === pipcook_core_1.PipelineStatus.SUCCESS) {
                    // append it for successful job.
                    return true;
                }
            });
            if (jobs.length === 0) {
                throw new TypeError('no job is finished.');
            }
            const outputs = yield this.downloadOutputs(jobs);
            yield this.buildOutputs(outputs, tuna);
            this.manifest.executable = true;
            // save the manifest to sync
            yield this.saveManifest();
        });
    }
    /**
     * Ensure the plugins for all generated pipelines.
     */
    ensureAllPlugins(hooks) {
        var e_2, _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                for (var _b = __asyncValues(this.manifest.pipelines), _c; _c = yield _b.next(), !_c.done;) {
                    const { id } = _c.value;
                    yield this.ensurePluginsByPipeline(id, hooks);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Ensure the plugins for a given pipeline id.
     * @param id the pipeline id.
     */
    ensurePluginsByPipeline(id, hooks) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                request_1.listen(`${router_1.route.pipeline}/${id}/install`, {
                    cwd: cwd(),
                    pyIndex: config_1.tunaMirrorURI
                }, {
                    'info': (e) => {
                        const plugin = JSON.parse(e.data);
                        hooks === null || hooks === void 0 ? void 0 : hooks.before(plugin.name, plugin.version);
                    },
                    'installed': (e) => {
                        const plugin = JSON.parse(e.data);
                        hooks === null || hooks === void 0 ? void 0 : hooks.after(plugin.name, plugin.version);
                    },
                    'finished': () => {
                        resolve();
                    },
                    'error': (e) => {
                        const installErr = new TypeError(`installed failed with ${e.data}`);
                        reject(installErr);
                    }
                });
            });
        });
    }
    downloadOutputs(jobs) {
        return __awaiter(this, void 0, void 0, function* () {
            // cleanup the current model root
            yield fs_extra_1.remove(this.modelRootPath);
            return Promise.all(jobs.map(this.downloadSingleOutput));
        });
    }
    /**
     * Build the outputs.
     * @param outputs the outputs directory
     */
    buildOutputs(outputs, tuna) {
        var outputs_1, outputs_1_1;
        var e_3, _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                for (outputs_1 = __asyncValues(outputs); outputs_1_1 = yield outputs_1.next(), !outputs_1_1.done;) {
                    const outputDir = outputs_1_1.value;
                    const opts = { cwd: outputDir };
                    if (tuna === true) {
                        opts.env = Object.assign({ BOA_CONDA_INDEX: common_1.Constants.BOA_CONDA_INDEX, BOA_CONDA_MIRROR: common_1.Constants.BOA_CONDA_MIRROR }, process.env);
                    }
                    yield common_1.execNpm('install', '--production', opts);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (outputs_1_1 && !outputs_1_1.done && (_a = outputs_1.return)) yield _a.call(outputs_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Save the manifest
     */
    saveManifest() {
        return __awaiter(this, void 0, void 0, function* () {
            return fs_extra_1.writeJSON(this.manifestPath, this.manifest, {
                spaces: 2
            });
        });
    }
}
exports.AppProject = AppProject;
//# sourceMappingURL=app.js.map