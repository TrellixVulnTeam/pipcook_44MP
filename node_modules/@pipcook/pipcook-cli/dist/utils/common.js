"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.traceLogger = exports.logger = exports.extractToPath = exports.initClient = exports.streamToJson = exports.parseConfigFilename = exports.tail = exports.execNpm = exports.execAsync = exports.client = exports.cwd = exports.Constants = void 0;
const url = __importStar(require("url"));
const child_process_1 = require("child_process");
const tar_stream_1 = __importDefault(require("tar-stream"));
const zlib_1 = require("zlib");
const fs_extra_1 = require("fs-extra");
const path_1 = __importDefault(require("path"));
const pipcook_core_1 = require("@pipcook/pipcook-core");
const sdk_1 = require("@pipcook/sdk");
const realOra = require("ora");
exports.Constants = {
    BOA_CONDA_INDEX: 'https://pypi.tuna.tsinghua.edu.cn/simple',
    BOA_CONDA_MIRROR: 'https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda'
};
exports.cwd = process.cwd;
function execAsync(cmd, opts) {
    return new Promise((resolve, reject) => {
        child_process_1.exec(cmd, opts, (err, stdout) => {
            err == null ? resolve(stdout) : reject(err);
        });
    });
}
exports.execAsync = execAsync;
function execNpm(subcmd, flags, opts) {
    return new Promise((resolve, reject) => {
        const cli = child_process_1.spawn('npm', [subcmd, flags], Object.assign({ stdio: 'inherit', env: process.env }, opts));
        cli.on('exit', resolve);
        cli.on('error', reject);
    });
}
exports.execNpm = execNpm;
function tail(id, name) {
    return child_process_1.spawn('tail', [
        '-f',
        `${pipcook_core_1.constants.PIPCOOK_HOME_PATH}/components/${id}/logs/${name}.log`
    ], {
        stdio: 'inherit'
    });
}
exports.tail = tail;
function parseConfigFilename(filename) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!filename) {
            throw new TypeError('Please specify the config path');
        }
        let urlObj = url.parse(filename);
        // file default if the protocol is null
        if (urlObj.protocol == null) {
            filename = path_1.default.isAbsolute(filename) ? filename : path_1.default.join(process.cwd(), filename);
            // check the filename existence
            if (!(yield fs_extra_1.pathExists(filename))) {
                throw new TypeError(`${filename} not exists`);
            }
            else {
                urlObj = url.parse(`file://${filename}`);
            }
        }
        else if (['http:', 'https:'].indexOf(urlObj.protocol) === -1) {
            throw new TypeError(`protocol '${urlObj.protocol}' is not supported`);
        }
        return urlObj;
    });
}
exports.parseConfigFilename = parseConfigFilename;
function streamToJson(stream) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            let jsonStr = '';
            stream.on('data', (chunk) => {
                jsonStr += chunk;
            });
            stream.on('error', (err) => {
                reject(err);
            });
            stream.on('end', () => {
                try {
                    const jsonObj = JSON.parse(jsonStr);
                    resolve(jsonObj);
                }
                catch (err) {
                    reject(err);
                }
            });
        });
    });
}
exports.streamToJson = streamToJson;
/**
 * init and get the client
 * @param host host name or ip, default value is '127.0.0.1'
 * @param port port default 6927
 */
function initClient(host = '127.0.0.1', port = 6927) {
    if (!exports.client) {
        exports.client = new sdk_1.PipcookClient(`http://${host}`, port);
    }
    return exports.client;
}
exports.initClient = initClient;
function extractToPath(stream, outputPath) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const extract = tar_stream_1.default.extract();
            const gunZip = zlib_1.createGunzip();
            extract.on('entry', (header, stream, next) => __awaiter(this, void 0, void 0, function* () {
                const dist = path_1.default.join(outputPath, header.name);
                if (header.type === 'directory') {
                    yield fs_extra_1.mkdirp(dist);
                }
                else if (header.type === 'file') {
                    stream.pipe(fs_extra_1.createWriteStream(dist));
                }
                stream.on('end', next);
                stream.resume();
            }));
            extract.on('error', (err) => {
                reject(err);
            });
            extract.on('finish', () => {
                resolve();
            });
            gunZip.on('error', (err) => {
                reject(err);
            });
            stream.pipe(gunZip).pipe(extract);
        });
    });
}
exports.extractToPath = extractToPath;
class TtyLogger {
    constructor() {
        this.spinner = realOra({ stream: process.stdout });
    }
    success(message) {
        this.spinner.succeed(message);
    }
    fail(message, exit = true, code = 1) {
        this.spinner.fail(message);
        if (exit) {
            process.exit(code);
        }
    }
    info(message) {
        this.spinner.info(message);
    }
    warn(message) {
        this.spinner.warn(message);
    }
    start(message) {
        this.spinner.start(message);
    }
}
class DefaultLogger {
    success(message) {
        console.log('[success]: ' + message);
    }
    fail(message, exit = true, code = 1) {
        console.error('[fail]: ' + message);
        if (exit) {
            process.exit(code);
        }
    }
    info(message) {
        console.log('[info]: ' + message);
    }
    warn(message) {
        console.warn('[warn]: ' + message);
    }
    start(message) {
        console.log('[start]: ' + message);
    }
}
const { rows, columns, isTTY } = process.stdout;
exports.logger = isTTY && rows > 0 && columns > 0 ? new TtyLogger() : new DefaultLogger();
function traceLogger(event, data) {
    if (event === 'log') {
        if (data.level === 'info') {
            exports.logger.info(data.data);
        }
        else if (data.level === 'warn') {
            exports.logger.warn(data.data);
        }
    }
    else if (event === 'job_status') {
        if (data.jobStatus === pipcook_core_1.PipelineStatus.PENDING) {
            exports.logger.info(`[job] pending: ${data.queueLength}`);
        }
        else if (data.jobStatus === pipcook_core_1.PipelineStatus.RUNNING) {
            exports.logger.info(`[job] running${data.step ? ` ${data.step} ${data.stepAction}` : ''}`);
        }
        else if (data.jobStatus === pipcook_core_1.PipelineStatus.FAIL) {
            exports.logger.info('[job] fails');
        }
        else if (data.jobStatus === pipcook_core_1.PipelineStatus.SUCCESS) {
            exports.logger.info('[job] run successfully');
        }
    }
}
exports.traceLogger = traceLogger;
//# sourceMappingURL=common.js.map